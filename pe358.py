'''
if p is cyclic it must be prim and

1/p=m/(10**(p-1)-1)

with m ending with 56789

10**(p-1)-1=m*p

mod 10**5 we get

99999=56789*p mod 10**5

p must end with 09891
'''
'''
 Project Euler 358 cyclic number
Last night, I took a while on Problem 358.
Here’s the approach without the help of matlab or mathmatica or VS.
The main idea of this solution is summed up as below:
1, Cyclic number generated by 1/p, p is a prime number.
2, Prove that SUM(all digits of cyclic number)=(p-1)*9/2
3, the last 5 digits of p can be calculated by hand
Conclusion: All help from outside we need is a list of all prime numbers within 724’000’000 to 729’999’999

Brief Proof:
1, Since what makes cyclic number cyclic is:
[MOD p]: exist a=10
10/p, 100/p, 1000/p, … , 10^(p-2) in {2, 3, … ,p-1} && 10^(p-1) =1
therefore p is prime (Lehmer’s theorem)
2, This part is simple, if Sn=a1+a2+…+an
a1a2a3a4…an is cyclic, then
a1a2a3a4…an *1
a1a2a3a4…an *2
…
a1a2a3a4…an *(n-1)
+)
______________
Sn*111111…1(n-1 digit)=a1a2a3a4…an*(1+2+…+(n-1))
Therefore, Sn*1111..1(n-1 digit)=999..9(n-1 digit) * (1/n) * (n-1)n/2
=> Sn=9*(n-1)/2

3, The last 5 digit can be calculated as below:
exists N<p, N/p = 0.5678900000000137xxxxx…
=> (N*10^5)/p = 56789+1.37*10^(-9)
=> p*(56789+1.37*10^(-9)) = (N*10^5)
Since p is within (1/0.00000000137, 1/0.00000000138)
=> p is about 7 * 10^9 => p*1.37*10^(-9) is about 1;
Since (N*10^5) can only be an integer, p*1.37*10^(-9) = 1

Therefore we reach a simple conclusion that p * 56789 = N*10^5 – 1 ends with 99999 as the last 5 digits.

The last 5 digits of p can then be calculated simply by hand, that is 09891

Conclusion, with the prime number list http://primes.utm.edu/lists/small/millions/
Altogether 3 hits with last 5 digits as ‘09891’ & within (724’000’000, 729’999’999)
They are 725509891, 726509891, 729809891.
Verify those 3, and we can reach our answer (729809891) :)
'''
def get_all_digit_set(digit):
    return set(digit[i:] + digit[:i] for i in range(len(digit)))
def check_digit(digit):
    L = len(digit)
    int_digit = int(digit)
    digit_set = get_all_digit_set(digit)
    def same_digit(t):
        str_t = str(t)
        str_t = '0' * (L-len(str_t)) + str_t
        return str_t in digit_set
    for i in range(1, L+1):
        t = int_digit * i
        if not same_digit(t):
            return False
    return True

#print (check_digit('0169491525423728813559322033898305084745762711864406779661'))

def cal():
    a, b = '00000000137', '56789'
    mid_value = 1
    while 1:
        if mid_value % 10000 == 0:
            print ('mid_value', mid_value)
        value = a + str(mid_value) + b
        if check_digit(value):
            print (value)
            break
        mid_value += 1


def new_cal():
    for p in open('prime.txt'):
        if int(p) > 5:
            p = int(p) - 1
            t = (10**p - 1)// (p+1)
            if t % 100000 == 56789:
                t = str(t)
                if t.startswith('137'):
                    if check_digit('00000000' + t):
                        print ('sum is', sum(int(i) for i in t))
                        break
        print (p)
    
#new_cal()

def test_cycle(p):
    t,r,n = 0, 1, 0
    b = 10
    c = 0
    while 1:
        t += 1
        x = r * b
        d = x // p
        r = x % p
        n = n * b + d
        if r == 1:
            break
    if t == p - 1:
        return n
    return 0
p = 729809891
ans = 10 ** (p-1) // p
s = 0
while ans != 0:
    s += ans % 10
    ans /= 10
print (s)
#print (sum(int(i) for i in str(ans)))
